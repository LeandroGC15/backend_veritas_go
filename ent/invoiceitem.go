// Code generated by ent, DO NOT EDIT.

package ent

import (
	"Veritasbackend/ent/invoice"
	"Veritasbackend/ent/invoiceitem"
	"fmt"
	"strings"

	"entgo.io/ent/dialect/sql"
)

// InvoiceItem is the model entity for the InvoiceItem schema.
type InvoiceItem struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// ID de la factura
	InvoiceID int `json:"invoice_id,omitempty"`
	// ID del producto
	ProductID int `json:"product_id,omitempty"`
	// Cantidad vendida
	Quantity int `json:"quantity,omitempty"`
	// Precio unitario al momento de la venta
	UnitPrice float64 `json:"unit_price,omitempty"`
	// Subtotal (quantity * unit_price)
	Subtotal float64 `json:"subtotal,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the InvoiceItemQuery when eager-loading is set.
	Edges InvoiceItemEdges `json:"edges"`
}

// InvoiceItemEdges holds the relations/edges for other nodes in the graph.
type InvoiceItemEdges struct {
	// Invoice holds the value of the invoice edge.
	Invoice *Invoice `json:"invoice,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [1]bool
}

// InvoiceOrErr returns the Invoice value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e InvoiceItemEdges) InvoiceOrErr() (*Invoice, error) {
	if e.loadedTypes[0] {
		if e.Invoice == nil {
			// The edge invoice was loaded in eager-loading,
			// but was not found.
			return nil, &NotFoundError{label: invoice.Label}
		}
		return e.Invoice, nil
	}
	return nil, &NotLoadedError{edge: "invoice"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*InvoiceItem) scanValues(columns []string) ([]interface{}, error) {
	values := make([]interface{}, len(columns))
	for i := range columns {
		switch columns[i] {
		case invoiceitem.FieldUnitPrice, invoiceitem.FieldSubtotal:
			values[i] = new(sql.NullFloat64)
		case invoiceitem.FieldID, invoiceitem.FieldInvoiceID, invoiceitem.FieldProductID, invoiceitem.FieldQuantity:
			values[i] = new(sql.NullInt64)
		default:
			return nil, fmt.Errorf("unexpected column %q for type InvoiceItem", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the InvoiceItem fields.
func (ii *InvoiceItem) assignValues(columns []string, values []interface{}) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case invoiceitem.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			ii.ID = int(value.Int64)
		case invoiceitem.FieldInvoiceID:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field invoice_id", values[i])
			} else if value.Valid {
				ii.InvoiceID = int(value.Int64)
			}
		case invoiceitem.FieldProductID:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field product_id", values[i])
			} else if value.Valid {
				ii.ProductID = int(value.Int64)
			}
		case invoiceitem.FieldQuantity:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field quantity", values[i])
			} else if value.Valid {
				ii.Quantity = int(value.Int64)
			}
		case invoiceitem.FieldUnitPrice:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field unit_price", values[i])
			} else if value.Valid {
				ii.UnitPrice = value.Float64
			}
		case invoiceitem.FieldSubtotal:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field subtotal", values[i])
			} else if value.Valid {
				ii.Subtotal = value.Float64
			}
		}
	}
	return nil
}

// QueryInvoice queries the "invoice" edge of the InvoiceItem entity.
func (ii *InvoiceItem) QueryInvoice() *InvoiceQuery {
	return (&InvoiceItemClient{config: ii.config}).QueryInvoice(ii)
}

// Update returns a builder for updating this InvoiceItem.
// Note that you need to call InvoiceItem.Unwrap() before calling this method if this InvoiceItem
// was returned from a transaction, and the transaction was committed or rolled back.
func (ii *InvoiceItem) Update() *InvoiceItemUpdateOne {
	return (&InvoiceItemClient{config: ii.config}).UpdateOne(ii)
}

// Unwrap unwraps the InvoiceItem entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (ii *InvoiceItem) Unwrap() *InvoiceItem {
	_tx, ok := ii.config.driver.(*txDriver)
	if !ok {
		panic("ent: InvoiceItem is not a transactional entity")
	}
	ii.config.driver = _tx.drv
	return ii
}

// String implements the fmt.Stringer.
func (ii *InvoiceItem) String() string {
	var builder strings.Builder
	builder.WriteString("InvoiceItem(")
	builder.WriteString(fmt.Sprintf("id=%v, ", ii.ID))
	builder.WriteString("invoice_id=")
	builder.WriteString(fmt.Sprintf("%v", ii.InvoiceID))
	builder.WriteString(", ")
	builder.WriteString("product_id=")
	builder.WriteString(fmt.Sprintf("%v", ii.ProductID))
	builder.WriteString(", ")
	builder.WriteString("quantity=")
	builder.WriteString(fmt.Sprintf("%v", ii.Quantity))
	builder.WriteString(", ")
	builder.WriteString("unit_price=")
	builder.WriteString(fmt.Sprintf("%v", ii.UnitPrice))
	builder.WriteString(", ")
	builder.WriteString("subtotal=")
	builder.WriteString(fmt.Sprintf("%v", ii.Subtotal))
	builder.WriteByte(')')
	return builder.String()
}

// InvoiceItems is a parsable slice of InvoiceItem.
type InvoiceItems []*InvoiceItem

func (ii InvoiceItems) config(cfg config) {
	for _i := range ii {
		ii[_i].config = cfg
	}
}
